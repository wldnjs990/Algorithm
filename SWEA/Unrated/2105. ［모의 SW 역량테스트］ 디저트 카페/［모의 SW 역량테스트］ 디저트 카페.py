# 디저트 카페

# 한 변의 길이가 N인 정사각형 모양을 가진 지역에 디저트 카페가 모여 있다.
# 숫자는 해당 디저트 카페에서 팔고 있는 디저트의 종류를 의미하고

# 카페들 사이에는 대각선 방향으로 움직일 수 있는 길들이 있다.
# 디저트 카페 투어는 어느 한 카페에서 출발하여 대각선 방향으로 움직이고 사각형 모양을 그리며 출발한 카페로 돌아와야 한다.

# 디저트 카페 투어를 하는 도중 해당 지역을 벗어나면 안 된다.
# 또한, 친구들은 같은 종류의 디저트를 다시 먹는 것을 싫어한다.
# 카페 투어 중에 같은 숫자의 디저트를 팔고 있는 카페가 있으면 안 된다.

# 하나의 카페에서 디저트를 먹는 것도 안 된다.
# 왔던 길을 다시 돌아가는 것도 안 된다.

# 친구들과 디저트를 되도록 많이 먹으려고 한다.
# 디저트 가게가 모여있는 지역의 한 변의 길이 N과 디저트 카페의 디저트 종류가 입력으로 주어질 때,
# 임의의 한 카페에서 출발하여 대각선 방향으로 움직이고
# 서로 다른 디저트를 먹으면서 사각형 모양을 그리며 다시 출발점으로 돌아오는 경우,
# 디저트를 가장 많이 먹을 수 있는 경로를 찾고, 그 때의 디저트 수를 정답으로 출력하는 프로그램을 작성하라.
# 만약, 디저트를 먹을 수 없는 경우 -1을 출력한다.

# [제약사항]
# 1. 시간제한 : 최대 50개 테스트 케이스를 모두 통과하는 데 C/C++/Java 모두 3초
# 2. 디저트 카페가 모여있는 지역의 한 변의 길이 N은 4 이상 20 이하의 정수이다. (4 ≤ N ≤ 20)
# 3. 디저트 종류를 나타나는 수는 1 이상 100 이하의 정수이다.

# [입력]
# 입력의 맨 첫 줄에는 총 테스트 케이스의 개수 T가 주어지고, 그 다음 줄부터 T개의 테스트 케이스가 주어진다.
# 각 테스트 케이스의 첫 번째 줄에는 디저트 카페가 모여있는 지역의 한 변의 길이 N이 주어진다.
# 그 다음 N 줄에는 N * N 크기의 디저트 카페에서 팔고 있는 디저트 종류에 대한 정보가 주어진다.

# [출력]
# 테스트 케이스 개수만큼 T개의 줄에 각각의 테스트 케이스에 대한 답을 출력한다.
# 각 줄은 "#t"로 시작하고 공백을 하나 둔 다음 정답을 출력한다. (t는 1부터 시작하는 테스트 케이스의 번호이다)
# 출력해야 할 정답은 가능한 경우 중 디저트를 가장 많이 먹을 때의 디저트 수 이다.
# 만약, 디저트를 먹을 수 없는 경우 정답은 -1이다.

# [문제풀이]
# 모든 모서리는 어짜피 사각형을 못 만드니 빼자.
# 델타를 만들어서 델타를 사용하는 경우, 사용하지 않는 경우 2가지로 나누어서 진행
# 델타방향 = 0, 1, 2, 3

# 가지치기 조건들
# 1. 지도를 벗어났을때
# 2. visited에 걸렸을때
# 3. 중복되는 카페메뉴를 갔을 경우
# 4. 0방향으로 이동한 수 만큼 2방향에서 이동 못 한 경우, 또는 초과한 경우
# 5. 1방향으로 이동한 수 만큼 3방향에서 이동 못 한 경우, 또는 초과한 경우
# 6. 현재 0방향의 최대 길이가 충족되지 않았는데 1방향으로 이동하려고 하는 경우
# 7. 현재 1방향의 최대 길이가 충족되지 않았는데 2방향으로 이동하려고 하는 경우

# 백트래킹(x축, y축, 현재 방향, 첫번째 방향으로 이동한 거리, 두번째 방향으로 이동한 거리, 먹은 디저트 수)
# 다이아몬드로 순회하면 N이 20이라도 걸리는 일은 없으려나
# 순열 만들기인가
def back_tracking(x, y, di, st_m, nd_m, rd_m, th_m, cnt):
    # nd_m과 th_m이 같아졌다면 사각형이 완성된 것
    if nd_m != 0 and nd_m == th_m:
        cnt_arr.append(cnt)
        return

    # 다음지역(정방향)
    nx = x + dx[di]
    ny = y + dy[di]
    # 정방향으로 이동 시도(범위를 벗어나지 않고, 아직 먹지 않은 디저트인 경우)
    if nx >= 0 and ny >= 0 and nx < N and ny < N and not visited[cafes[ny][nx]]:
        # 디저트 체크
        visited[cafes[ny][nx]] = 1
        if di == 0:
            # 0방향 직진이면 st_m길이 추가
            back_tracking(nx, ny, di, st_m + 1, nd_m, rd_m, th_m, cnt + 1)
        elif di == 1:
            # 1방향 직진이면 nd_m길이 추가
            back_tracking(nx, ny, di, st_m, nd_m + 1, rd_m, th_m, cnt + 1)
        elif di == 2:
            # 1방향 직진이면 nd_m길이 추가
            back_tracking(nx, ny, di, st_m, nd_m, rd_m + 1, th_m, cnt + 1)
        elif di == 3:
            # 1방향 직진이면 nd_m길이 추가
            back_tracking(nx, ny, di, st_m, nd_m, rd_m, th_m + 1, cnt + 1)
        # 정방향 디저트 체크 해제
        visited[cafes[ny][nx]] = 0

    # 마지막 회전까지 가지 않았다면
    if di + 1 <= 3:
        # 다음지역(회전)
        rx = x + dx[di + 1]
        ry = y + dy[di + 1]
        # 회전방향으로 이동 시도(범위를 벗어나지 않고, 아직 먹지 않은 디저트인 경우)
        if rx >= 0 and ry >= 0 and rx < N and ry < N and not visited[cafes[ry][rx]]:
            # 회전방향 디저트 체크
            visited[cafes[ry][rx]] = 1
            # 0방향에, 한번이라도 이동한 경우 이동 가능
            if di == 0 and st_m > 0:
                back_tracking(rx, ry, di + 1, st_m, nd_m + 1, rd_m, th_m, cnt + 1)
            # 1방향에, 한번이라도 이동한 경우 이동 가능
            elif di == 1 and nd_m > 0:
                back_tracking(rx, ry, di + 1, st_m, nd_m, rd_m + 1, th_m, cnt + 1)
            # 2방향에, 한번이라도 이동했고, 회전하려 할 때 st_m와 rd_m의 길이가 동일하다면 이동 가능
            elif di == 2 and rd_m > 0 and st_m == rd_m:
                back_tracking(rx, ry, di + 1, st_m, nd_m, rd_m, th_m + 1, cnt + 1)
            # 회전방향 디저트 체크해제
            visited[cafes[ry][rx]] = 0

T = int(input())

for tc in range(1, T+1):
    N = int(input())

    cafes = [list(map(int, input().split())) for _ in range(N)]
    # 디저트 기록
    visited = [0] * 101

    # 다이아몬드 델타
    dx = [-1, 1, 1, -1]
    dy = [1, 1, -1, -1]

    cnt_arr = []

    for y in range(N):
        for x in range(N):
            # # 시작 디저트 체크
            # visited[cafes[y][x]] = 1
            back_tracking(x, y, 0, 0, 0, 0, 0, 0)

    if cnt_arr:
        print(f'#{tc} {max(cnt_arr)}')
    else:
        print(f'#{tc} {-1}')


