import sys;
input = sys.stdin.readline
# 가희와 탑

# 일직선으로 다양한 높이의 건물들이 N개 존재합니다.
# 가희는 건물들의 왼쪽에, 단비는 건물들의 오른쪽에 있습니다.
# 일직선 상에 가희와 단비, 건물들은 아래와 같은 순서로 배치되어 있습니다.

# 가희의 오른쪽에는 1번 건물이 있습니다.
# x가 1이상 N-1이하의 정수일 때, x번 건물의 오른쪽에는 x+1번 건물이 있습니다.
# N번 건물의 오른쪽에는 단비가 있습니다.

# 가희와 단비가 볼 수 있는 건물은 아래와 같습니다.

# 가희는 1번 건물을 볼 수 있습니다.
# k번 건물보다 왼쪽에 있는 건물들이 모두 k번 건물보다 높이가 낮다면, 가희는 k번 건물을 볼 수 있습니다.
# 단비는 N번 건물을 볼 수 있습니다.
# k번 건물보다 오른쪽에 있는 건물들이 모두 k번 건물보다 높이가 낮다면, 단비는 k번 건물을 볼 수 있습니다.

# 가희가 3번 건물을 볼 수 없는 이유는 3번 건물 왼쪽에 있는 2번 건물의 높이가 3번 건물보다 높기 때문입니다.
# 그리고, 단비가 1번 건물을 볼 수 없는 이유는 1번 건물보다 오른쪽에 있는 2번 건물과 3번 건물이 1번 건물보다 높기 때문입니다.

# 가희와 단비 사이에 있는 건물의 개수 N과 가희가 볼 수 있는 건물의 개수 a, 단비가 볼 수 있는 건물의 개수 b가 주어집니다.
# 사전 순으로 가장 앞서는 N개의 건물 높이 정보를 출력해 주세요.

# [입력]
# 첫째 줄에 건물의 개수 N, 가희가 볼 수 있는 건물의 개수 a, 단비가 볼 수 있는 건물의 개수 b가 공백으로 구분해서 주어집니다.

# [출력]
# 문제의 조건에 맞는 건물들의 높이 정보가 1개 이상 존재하는 경우 N개의 건물 높이 정보 중 사전순으로 가장 앞선 것을 출력해 주세요. 출력 형식은 다음을 만족해야 합니다.

# 1번 건물, ... , N번 건물의 높이를 공백으로 구분해서 출력해 주세요. 출력하는 수들이 모두 다를 필요는 없습니다.
# 높이는 1보다 크거나 같은 정수여야 합니다.

# 문제의 조건에 맞는 건물들의 높이 정보가 존재하지 않으면 첫 줄에 -1을 출력해 주세요.

# [제한]
# 1 ≤ N ≤ 105
# 1 ≤ a ≤ N
# 1 ≤ b ≤ N

# [문제 풀이]
# 사전순으로 나열이면 출력값의 건물 높이가 a또는 b의 최댓값을 넘길 수 없음
# 가희, 단비 상관없이 큰 숫자를 a로, 작은 숫자를 b로 초기화
# 큰 숫자 a는 1, 2, ... , a 까지 건물 추가
# 작은 숫자 b는 -1해주고 1, 2 ... , b 까지 건물 추가
# 여기서
# 1. b가 0이 되기 전에 N을 넘었다 == -1 반환하고 종료
# 2. b가 0이 되었는데 아직 N이 채워지지 않았다 == 가장 마지막으로 추가했던 건물 높이로 나머지 채워주기
# 마지막으로 정렬

# 이러면 되지 않을까...?
# 아래 문제에 추가로 적은 해설 보기

from collections import deque

def result():
    N, a, b = map(int, input().split())

    if a + b > N+1:
        return [-1]

    if N == 1 and a == 1 and b == 1:
        return [1]

    sm = ''
    # a와 b 중 작은 값 찾기
    # 작은거 -1 해주기
    # for문 돌릴건데, 작은애도 최댓값 까지 뽑아내면 문제가 꼬임
    # N = 6, a = 2, b = 3
    # a_arr = [1, 2], b = [3, 2, 1]
    # 이러면 a가 바라볼 수 있는 건물도 3개가 된다.
    # 그래서 빼줘야 하는거
    if a > b:
        sm = 'b'
        if not (a == b and a + b == N and N % 2 == 0):
            b -= 1
    elif a < b:
        sm = 'a'
        if not (a == b and a + b == N and N % 2 == 0):
            a -= 1

    a_arr = deque()
    b_arr = deque()
    # a만큼 건물 쌓기
    for i in range(1, a+1):
        a_arr.append(i)
    # b만큼 건물 쌓기
    for i in range(1, b+1):
        b_arr.append(i)
    b_arr.reverse()

    # 지금까지 쌓은 건물 길이
    total_len = len(a_arr) + len(b_arr)
    # N 보다 건물 길이가 긴 경우
    if total_len > N:
        # 두 건물의 길이가 같은 경우는 1221 이런 경우니 1121로 고쳐주기
        if len(a_arr) == len(b_arr) and total_len - 1 == N:
            a_arr.pop()
            ans = [*a_arr] + [*b_arr]
            return ans
    # 아직 건물을 더 배치해야 하는 경우
    elif total_len < N:
        # 추가해야할 나머지 건물 길이 구하기
        least = N - total_len
        # a가 작은 경우
        if sm == 'a':
            # a_arr 건물이 하나도 없으면
            # ex. N = 5, a_arr = [], b_arr = [3, 2, 1]
            if len(a_arr):
                # a에 나머지 길이만큼 1로 채워주기
                # 1 1 3 2 1
                for _ in range(least):
                    a_arr.appendleft(1)
            # a_arr 건물이 하나라도 있으면
            # ex. N = 5, a_arr = [1], b_arr = [3, 2, 1]
            else:
                # 여기서 나올수 있는 사전순으로 가장 가까운 수는
                # 1 3 1 2 1 임
                # 그래서 b 가장 큰 수 사이에 나머지 건물들을 1로 채워줘야 함

                # b 최대값 저장 + 제거
                temp = b_arr.popleft()
                # b 앞에 least만큼 1 담아주기
                for _ in range(least):
                    b_arr.appendleft(1)
                # 저장해뒀던 최댓값 다시 담아주기
                b_arr.appendleft(temp)
        # b가 작은 경우
        elif sm == 'b':
            # N = 5, a_arr = [1, 2], b_arr = [1]
            # 이 경우엔 b에 오른쪽에 1을 쭉 채워주면 됨
            for _ in range(least):
                a_arr.appendleft(1)
        # a, b 값이 동일한 경우
        else:
            # N = 5, a = [1, 2], b = [2, 1]
            # a와 b 사이에 최댓값이 2개 있을 필요 없으니 a의 최댓값을 지우고, 왼쪽에 1 추가해주기
            # a의 왼쪽에 least만큼 1 채워주기
            # 1 1 1 2 1 이렇게 됨
            a_arr.pop()
            a_arr.appendleft(1)
            for _ in range(least):
                a_arr.appendleft(1)

        # 배열 합쳐주고 결과 반환
        ans = [*a_arr] + [*b_arr]
        return ans
    # a + b가 N과 동일한 경우
    else:
        # a와 b의 길이가 동일하고 N이 짝수다 == a랑 b가 N의 절반이다.
        # N = 4, a = [1, 2], b = [2, 1]
        # a와 b 사이에 최댓값이 2개 있을 필요 없으니 a의 최댓값을 지우고, 왼쪽에 1 추가해주기
        # a의 왼쪽에 least만큼 1 채워주기
        # 1 1 2 1 이렇게 됨
        if len(a_arr) == len(b_arr) and N % 2 == 0:
            a_arr.pop()
            a_arr.appendleft(1)

        # 배열 합쳐주고 결과 반환
        ans = [*a_arr] + [*b_arr]
        return ans

res = result()
print(*res)