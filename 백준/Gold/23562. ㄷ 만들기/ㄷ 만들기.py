# ㄷ 만들기

# 7개의 정사각형으로 이루어진 ㄷ 모양을 만들어야 함
# n * m 크기의 모눈을 주는데, 모눈의 칸을 지우거나 채워서 ㄷ이 되도록 만들 수 있다.
# 흰색 칸을 검은색으로 칠하는 데 드는 비용은 a, 검
# 은색 칸을 지워서 흰색 칸으로 만드는 데 드는 비용은 b다. 
# 검은색 칸들이 ㄷ 모양을 이룰 수 있도록 하기 위해 드는 최소 비용을 구하는 프로그램을 작성하자.

# [입력]
# 첫 번째 줄에 모눈종이의 크기 n, m이 주어진다.
# 두 번째 줄에 칸의 색깔을 바꾸는 데 드는 비용 a,b가 주어진다.
# 다음 n개의 줄에 길이 m인 문자열이 주어진다. #은 검은색으로 칠해진 칸, .은 흰색 칸을 의미한다.

# [출력]
# 첫 번째 줄에 ㄷ 모양을 만들 수 있는 최소 비용을 출력한다.

# [제한]
# 3 <= n, m <= 20
# 1 <= a, b <= 1000

# [문제 풀이]
# 20 * 20 == 400 이니 dfs 가능?
# 모눈이 만들어지려면 일단 크기가 정사각형이 되어야 함
# 정사각형의 크기는 최소 3 * 3이어야 함
# 그리고 정사각형은 3의 배수여야 ㄷ자가 됨
# n, m 중에서 더 짧은 길이를 기준으로 3 ~ (짧은 n 또는 m)까지 구할 수 있는 모든 ㄷ자 만들기 비용을 구해야 할 거 같은데?
# 슬라이딩 윈도우 써서 푼다고 치면 최악의 경우 20 ~ 3 까지의 3의 배수를 가지는 모든 ㄷ자 케이스를 찾아야 함
# 터무니 없이 많은데
# 3칸만 계신해봐도
# 타겟 9칸 + 나머지 391칸 * 가로 17 * 세로 17
# 400 * 17 * 17
# 115600
# ?
# 별로 안드네?
# 걍 가지치키 하면서 풀어야겠다

# 모눈에 있는 검정색 전부 하얀색으로 바꾸는 비용 구해놓고 슬라이딩 윈도우 하면서 검은색이어야 하는 부분의 경우를 더하거나 빼서 구하면 더 수월할거 같은데

# 그리고 흰색이 되어야 하는 부분은 3 * 3 기준으로 (2, 2), (2, 3) 이렇게임 (y, x)
# 흰색으로 바꿀 영역을 찾는 방법은...
# x축은 1/3 다음부터 3/3 끝까지
# y축은 1/3 다음부터 2/3 끝까지
# 잘 구해보자..
# 3으로 몫 없애고 연산 계산했을때 (2, 2), (2, 3)이 되는 영역들만 흰색으로 취급하면 되지 않을까?

# [풀이 시간]
# 6:00


# 세로 : n, 가로 : m
n, m = map(int, input().split())
# 채우기 비용 a, 빼기 비용 b
a, b = map(int, input().split())

# 모눈종이
monun_arr = [list(input()) for _ in range(n)]

# 전부 흰색으로 바꾸는 비용 계산
white_price = 0
for y in range(n):
  for x in range(m):
    if(monun_arr[y][x] == '#'):
      white_price += b

# 짧은 길이
short = min(n, m)

# 결과
ans = 100_000_000

# 짧은 길이가 3 미만이 될 때 까지 비용 구하기
while short >= 3:
  # short가 3의 배수가 아니면 패쓰
  if short % 3 != 0:
    # 다음 길이 구하기
    short -= 1
    continue

  # 3 * 3으로 나눴을때 한 칸 길이
  one_len = short // 3

  # 맵 벗어나지 않는 선에서 슬라이딩 윈도우 진행
  for y in range(n - short + 1):
    for x in range(m - short + 1):
      now_price = white_price
      for i in range(short):
        ny = y + i
        for j in range(short):
          nx = x + j
          # 현재 구간이 흰색이여야 하는지 확인(현재 칸 = 2, 2)
          if one_len * 2 >= i+1 and i+1 > one_len and one_len * 2 >= j+1 and j+1 > one_len:
            # 흰색이면 패스
            continue
          # 현재 구간이 흰색이여야 하는지 확인(현재 칸 = 2, 3)
          elif one_len * 2 >= i+1 and i+1 > one_len and one_len * 2 < j+1:
            # 흰색이면 패스
            continue
          else:
            # 검은색이면 현재 칸이 원래 검은색이었다면 잘못 바꾼거니 흰색 변환 비용 b 빼주기
            if monun_arr[ny][nx] == '#':
              now_price -= b
            # 아니면 흰색 칸이니 검은색 변환 비용 a 더해주기
            else :
              now_price += a
      # ans 업데이트
      ans = min(ans, now_price)

  # 다음 길이 구하기
  short -= 1

print(ans)