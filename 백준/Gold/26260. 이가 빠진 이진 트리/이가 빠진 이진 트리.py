# 이가 빠진 이진트리

# 김소마는 최근에 포화 이진 트리에 대해 배웠다. 
# 포화 이진 트리란, 이진 트리에서 리프 노드를 제외한 모든 노드가 두 자식 노드를 가지며, 모든 리프 노드가 채워진 것을 말한다. 
# 아래의 그림을 통해 쉽게 이해하자.

# 김소마는 예쁜 포화 이진 검색 트리를 그려 만족했지만, 밥 먹다 흘린 소스가 리프 노드 한 개를 가려버렸다. 
# 여기서 이진 검색 트리란, 모든 왼쪽 자식이 자신보다 작고, 모든 오른쪽 자식이 자신보다 큰 이진 트리를 이야기한다.

# 그림을 버리려던 찰나, 김소마는 갑자기 포화 이진 검색 트리를 유지하며, 임의의 수를 넣을 때, 트리 구조가 어떻게 바뀔지 궁금해졌다. 
# 멍청한 김소마를 위해 당신이 도와주자.

# [입력]
# 첫 번째 줄에 가려진 노드를 포함한 노드의 개수 N이 주어진다. (N은 포화 이진트리가 만들어지는 갯수로 주어지며 최대 2^17 - 1 까지 주어짐)
# 둘째줄에 노드들 값이 1 ~ N 까지 번호순으로 주어진다.
# 세 번째 줄에 트리에 넣을 수 X가 주어진다. (0 <= X <=  10^9)

# [출력]
# 첫 번째 줄에 바뀐 트리를 후위(postorder) 순회한 결과를 출력한다. 
# (단, 왼쪽 자식 노드를 먼저 방문한다.)

# [문제 풀이]
# 트리 다 까먹었네;
# 후위순회는 왼 -> 오 -> 중 이었나
# 완전 이진트리니깐 연결리스트 써도 되겠다
# 아니다 그냥 노드 전부 오름차순 정렬하고 그리디처럼 풀면 되지 않나?
# 후위순회 돌아가는 구조가..
# 서브트리 하나 기준으로 1 -> 3 -> 2
# 1 -> 3 -> 2 -> 5 -> 7 -> 6 -> 4
# 이게 쭈우욱 이어질거지?
# 그러면 4 다음에 완전 이진트리가 또 있다면 어떻게 될까?
# 1 -> 3 -> 2 -> 5 -> 7 -> 6 -> 4 -> 8 -> 10 -> 9 -> 12 -> 14 -> 13 -> 11

# 에라이

# 그냥 완전이진 트리 만들어서 후위순회 하면 끝인데 완전이진트리 만드는법이랑 후위순회 하는거 다 까먹어버림 ㅋㅋ;
# gpt 마렵네..

# 그 아마 트리를 그거 1차원짜리 노드 배열 3개 2차원 배열로 담아가지고 왼쪽, 오른쪽, 부모 이렇게 노드 지정해주는거였던거 같은데
# 아니야 근데 지금 문제에선 부모, 왼쪽자식, 오른쪽자식 그런 정보를 주는게 아니라 완전이진트리니깐 알아 만드쇼 그런건데
# 1차원 배열에 뭔가 dp마냥 인덱스 점화식 같은게 있었나..

# 그림 보니깐 그냥 오름차순으로 값들 정렬해주고 트리 직접 만들면 될듯?



N = int(input())
arr = list(map(int, input().split()))

plus = int(input())

# -1 자리에 값 담아주고 정렬하기
for i in range(len(arr)):
    if arr[i] == -1:
        arr[i] = plus
        break

arr.sort(reverse=True)

tree = [None] * (N+1)

# 트리 만드는건 중위 순회로 만들어야 하네
def makeTree(node):
    if node > N:
        return
    makeTree(node*2)
    tree[node] = arr.pop()
    makeTree(node*2 + 1)

makeTree(1)

# 출력하는건 후위순회로
def post(node):
    if node > N:
        return
    post(node*2)
    post(node*2 + 1)
    
    if node == 1 :
      print(tree[node])
    else:
      print(tree[node], end=' ')

post(1)
