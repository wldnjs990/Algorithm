import sys;
input = sys.stdin.readline
# 최소 회의실 갯수

# 서준이는 아빠로부터 N개의 회의를 모두 진행할 수 있는 최소 회의실 개수를 구하라는 미션을 받았다.
# 각 회의는 시작 시간과 끝나는 시간이 주어지고 한 회의실에서 동시에 두 개 이상의 회의가 진행될 수 없다.
# 단, 회의는 한번 시작되면 중간에 중단될 수 없으며 한 회의가 끝나는 것과 동시에 다음 회의가 시작될 수 있다.
# 회의의 시작 시간은 끝나는 시간보다 항상 작다.
# N이 너무 커서 괴로워 하는 우리 서준이를 도와주자.

# [입력]
# 첫째 줄에 배열의 크기 N(1 ≤ N ≤ 100,000)이 주어진다.
# 둘째 줄부터 N+1 줄까지 공백을 사이에 두고 회의의 시작시간과 끝나는 시간이 주어진다.
# 시작 시간과 끝나는 시간은 231−1보다 작거나 같은 자연수 또는 0이다.

# [출력]
# 첫째 줄에 최소 회의실 개수를 출력한다.

# [문제풀이]
# 이런 문제 풀어봤는데
# 회의 끝나는 시간이 긴 회의순으로 정렬해서 반복문 진행
# 회의 끝나는 시간 가장 큰 회의가 시작하는 시간에 다음으로 큰 회의의 끝나는 시간이 겹친다면 cnt +1 해주기
# 다음 회의의 끝나는 시간을 기준으로 그다음 회의도 똑같이 비교 진행

# 이거 말고 우선순위 큐로 접근해야 한다고 함
# 우선순위 큐 써서 어떻게 푸는거지..?
# 시작시간이 빠른 순으로 오름차순 정렬
# 힙큐를 사용하여 회의가 끝나는 시간을 담음
# 반복문을 돌려서 첫번째 힙큐의 끝나는 시간보다 현재 회의의 시작 시간이 크거나 같으면, 그 회의실을 이어서 사용 가능하다는 뜻
# 첫번째 힙큐의 회의 끝나는 시간을 현재 끝나는 시간으로 업데이트(heappop, heappush 활용)
# 끝까지 반복하고나면, 힙큐엔 필요한 회의실의 갯수만큼 원소가 담기게 됨

from heapq import heappop, heappush

N = int(input())

times = [list(map(int, input().split())) for _ in range(N)]

# 빠른 시간별로 정렬
times.sort()

# 힙큐
heap = []
# 첫번째 회의 담기
heappush(heap, times[0][1])

for i in range(1, N):
    if heap[0] <= times[i][0]:
        heappop(heap)
    heappush(heap, times[i][1])

print(len(heap))