import sys;
input = sys.stdin.readline
# 우리집엔 도서관이 있어

# 상근이는 컴퓨터 공학의 일인자가 되기 위해 책을 매우 많이 구매했다.
# 하지만, 집에 책장이 없어서 책을 탑처럼 쌓아놓고 있다.

# 오늘은 오랜만에 상근이가 집에서 휴식을 취하는 날이다.
# 상근이는 책을 알파벳 순서대로 정렬하려고 한다.
# 사전 순으로 가장 앞서는 책은 가장 위에 놓고, 가장 뒤에 있는 책은 가장 밑에 놓아야 한다.
# 책을 정렬할 때 사용할 수 있는 방법은 책 하나를 뺀 다음, 가장 위에 놓는 것이다.

# 책은 1부터 N까지 번호가 책 이름의 사전 순으로 매겨져 있다.
# 1은 사전 순으로 가장 앞서는 책이다.
# 따라서, 위에서부터 책의 번호를 읽으면 (1, 2, ..., N)이 되어야 한다.
# 예를 들어, 책이 3권있고 처음에 (3, 2, 1)로 쌓여있을 때, 2번 만에 사전순으로 책을 쌓을 수 있다.
# 가장 먼저, 2번 책을 뺀 다음에 가장 위에 놓는다. 그렇게 되면 (2, 3, 1)이 된다.
# 마지막으로, 1을 뺀 다음 가장 위에 놓으면 (1, 2, 3)이 된다.

# 현재 책이 어떻게 쌓여있는지가 주어졌을 때, 몇 번만에 사전 순으로 쌓을 수 있는지 구하는 프로그램을 작성하시오.

# [입력]
# 첫째 줄에 책의 개수 N이 주어진다. (N ≤ 300,000)
# 다음 N개 줄에는 가장 위에 있는 책부터 아래에 있는 책까지 순서대로 주어진다.

# [출력]
# 첫째 줄에 몇 번만에 책을 정렬할 수 있는지 출력한다.

# [문제 풀이]
# 책의 번호는 1 ~ N개로 중복되는 번호는 없는거 같음
# 뽑는건 내 맘대로 선택해서 뽑을 수 있는거 같음
# 그리디 문제인가?
# N이 30만이라서 1번 순회로 끝낼수 있어야 할 듯
# 1 ~ N+1 만큼 순회하면서 input을 하나씩 받는다
# 지금 받는 input이 현재 숫자보다 큰 숫자라면 결과값에 +1 하면 되지 않을까?
# 거꾸로 순회 ㄱㄱ

# 이거 아닌거 같음
# 최대 30만 만큼 빈 배열을 만들고, 거기에 숫자를 넣고, 교체하고 반복해야 할 거 같음
# 이것도 아닌거 같은데

# 기본값(now)을 0부터 잡아서 현재 숫자를 저장시키면서 이동한다.
# 그런데, 조건이 있음
# 저장한 숫자가 현재 숫자보다 큰 경우, 그 차이가 2 이상이면 ans에 더해주고 다음으로 넘어간다.
# 현재 숫자보다 작은 숫자들은 그냥 패쓰


N = int(input())

ans = 0
big = 1

for i in range(N):
    now = int(input())
    # big보다 2 더 큰 값이면
    if now - big > 1:
        # ans에 2 더해주기
        ans += now - big
        # big값 업데이트
        big = now
    # 그냥 다음 숫자면 업데이트
    elif now - big == 1 or now - big == 0:
        big = now

print(ans)