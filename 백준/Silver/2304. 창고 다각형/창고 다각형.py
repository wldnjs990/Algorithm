import sys;
input = sys.stdin.readline
# 창고 다각형

# N 개의 막대 기둥이 일렬로 세워져 있다. 
# 기둥들의 폭은 모두 1 m이며 높이는 다를 수 있다. 
# 이 기둥들을 이용하여 양철로 된 창고를 제작하려고 한다. 
# 창고에는 모든 기둥이 들어간다. 
# 이 창고의 지붕을 다음과 같이 만든다.

# 1. 지붕은 수평 부분과 수직 부분으로 구성되며, 모두 연결되어야 한다.
# 2. 지붕의 수평 부분은 반드시 어떤 기둥의 윗면과 닿아야 한다.
# 3. 지붕의 수직 부분은 반드시 어떤 기둥의 옆면과 닿아야 한다.
# 4. 지붕의 가장자리는 땅에 닿아야 한다.
# 5. 비가 올 때 물이 고이지 않도록 지붕의 어떤 부분도 오목하게 들어간 부분이 없어야 한다.

# 창고 주인은 창고 다각형의 면적이 가장 작은 창고를 만들기를 원한다. 
# 기둥들의 위치와 높이가 주어질 때, 가장 작은 창고 다각형의 면적을 구하는 프로그램을 작성하시오.

# [입력]
# 첫 줄에는 기둥의 개수를 나타내는 정수 N이 주어진다. 
# N은 1 이상 1,000 이하이다. 
# 그 다음 N 개의 줄에는 
# 각 줄에 각 기둥의 왼쪽 면의 위치를 나타내는 정수 L과 높이를 나타내는 정수 H가 한 개의 빈 칸을 사이에 두고 주어진다. 
# L과 H는 둘 다 1 이상 1,000 이하이다.

# [출력]
# 첫 줄에 창고 다각형의 면적을 나타내는 정수를 출력한다.

# [문제 풀이]
# 트리라기보단 그리디 문제 느낌인데?
# 건물이 높은 순서대로 정렬시키는게 맞나?
# 물이 고이지 않게 만드려면 가장 높은 건물 기준으로 좌, 우를 탐색시켜서 다음으로 가장 큰 건물들을 감싸주는 방식을 써야할 거 같은데
# 시간복잡도는 걱정할 필요 없는 수준이고
# 일단 건물 놓이는 순서대로 정렬시켜
# 그리고 거기에서 가장 높은 건물을 찾아
# 그리고 높은 건물 기준으로 좌우를 한번 더 탐색해서 다음으로 높은 건물, 각 건물의 끝단의 건물의 높이를 각각 구해
# 이제 양 옆으로 반복문을 하나씩 돌려서 다음 건물이 가장 높은 건물인지 확인하고, 아니면 다음 건물로 이동해
# 가장 높은 건물이면 그 건물로부터 길이 차이만큼 넓이를 구해주고 ans에 더해줘
# 그래고 다음으로 높은 건물을 지정해서 계속 이어가
# 마지막 건물에 닿았을때 무조건 현재 가장 높은 건물 높이랑 똑같을테니 똑같이 넓이 ans에 더해주고 끝

# 못 풀어서 gpt 참조했슴다..

import sys
input = sys.stdin.readline

N = int(input())
pillars = [tuple(map(int, input().split())) for _ in range(N)]
# x 오름차순 정렬
pillars.sort(key=lambda x: x[0])

# 가장 높은 기둥(여러 개면 가장 왼쪽 것) 찾기
max_h = -1
max_idx = -1
for i, (x, h) in enumerate(pillars):
    if h > max_h:
        max_h = h
        max_idx = i

area = 0

# 왼쪽 스윕: 처음 기둥부터 max_idx까지
cur_h = pillars[0][1]
prev_x = pillars[0][0]
for i in range(1, max_idx + 1):
    x, h = pillars[i]
    if h >= cur_h:
        # prev_x ~ x 구간은 cur_h로 채워짐
        area += (x - prev_x) * cur_h
        cur_h = h
        prev_x = x

# 오른쪽 스윕: 마지막 기둥부터 max_idx까지
cur_h = pillars[-1][1]
prev_x = pillars[-1][0]
for i in range(len(pillars) - 2, max_idx - 1, -1):
    x, h = pillars[i]
    if h >= cur_h:
        # x ~ prev_x 구간은 cur_h로 채워짐
        area += (prev_x - x) * cur_h
        cur_h = h
        prev_x = x

# 최대 기둥 자체의 한 칸(폭 1) 추가
area += pillars[max_idx][1]

print(area)
